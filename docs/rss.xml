<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://chess-brain.github.io/code</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://chess-brain.github.io/code</link></image><lastBuildDate>Thu, 25 Dec 2025 13:57:34 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>è±¡æ£‹è„‘çš„ç™»å½•æ³¨å†Œ</title><link>https://chess-brain.github.io/code/post/xiang-qi-nao-de-deng-lu-zhu-ce.html</link><description>```js
(function(Scratch) {
    'use strict';

    class LoginExtension {
        constructor() {
            this.users = {}; 
            this.ws = null;
            this.isOnline = false; 
            this.connectToServer();
        }

        connectToServer() {
            try {
                this.ws = new WebSocket('ws://localhost:8080'); 
                this.ws.onopen = () =&gt; {
                    this.isOnline = true;
                    console.log('Connected to cloud server');
                };
                this.ws.onmessage = (event) =&gt; {
                    const data = JSON.parse(event.data);
                    if (data.type === 'sync') {
                        this.users = data.users;
                    }
                };
                this.ws.onclose = () =&gt; {
                    this.isOnline = false;
                    console.log('Disconnected from cloud server');
                };
                this.ws.onerror = () =&gt; {
                    this.isOnline = false;
                };
            } catch (e) {
                this.isOnline = false;
            }
        }

        getInfo() {
            return {
                id: 'login',
                name: 'ç™»å½•æ‰©å±•',
                blocks: [
                    {
                        opcode: 'register',
                        blockType: Scratch.BlockType.COMMAND,
                        text: 'æ³¨å†Œ ç”¨æˆ·å [username] å¯†ç  [password]',
                        arguments: {
                            username: {
                                type: Scratch.ArgumentType.STRING,
                                defaultValue: 'user'
                            },
                            password: {
                                type: Scratch.ArgumentType.STRING,
                                defaultValue: 'pass'
                            }
                        }
                    },
                    {
                        opcode: 'login',
                        blockType: Scratch.BlockType.BOOLEAN,
                        text: 'ç™»å½• ç”¨æˆ·å [username] å¯†ç  [password]',
                        arguments: {
                            username: {
                                type: Scratch.ArgumentType.STRING,
                                defaultValue: 'user'
                            },
                            password: {
                                type: Scratch.ArgumentType.STRING,
                                defaultValue: 'pass'
                            }
                        }
                    },
                    {
                        opcode: 'isOnline',
                        blockType: Scratch.BlockType.BOOLEAN,
                        text: 'æ˜¯å¦å·²è”ç½‘'
                    }
                ]
            };
        }

        register(args) {
            const { username, password } = args;
            if (this.users[username]) {
                return; // ç”¨æˆ·å·²å­˜åœ¨
            }
            this.users[username] = password;
            if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({ type: 'sync', users: this.users })); // åŒæ­¥åˆ°äº‘ç«¯
            }
        }

        login(args) {
            const { username, password } = args;
            return this.users[username] === password;
        }

        isOnline() {
            return this.isOnline;
        }
    }

    Scratch.extensions.register(new LoginExtension());
})(Scratch);
```ã€‚</description><guid isPermaLink="true">https://chess-brain.github.io/code/post/xiang-qi-nao-de-deng-lu-zhu-ce.html</guid><pubDate>Thu, 25 Dec 2025 13:57:05 +0000</pubDate></item><item><title>è±¡æ£‹è„‘çš„æˆå°±ä¸æ’è¡Œæ¦œ</title><link>https://chess-brain.github.io/code/post/xiang-qi-nao-de-cheng-jiu-yu-pai-xing-bang.html</link><description># è±¡æ£‹è„‘çš„æˆå°±ä¸æ’è¡Œæ¦œ
## è¯´æ˜ï¼š
è¿™æ˜¯ä¸€ä¸ªå¯ä»¥å®ç°æˆå°±ä¸æ’è¡Œæ¦œçš„æ‰©å±•
æˆ‘ä»¬çš„å£å·ï¼šå¹²å®Gandiçš„ç‰¹æœ‰åŠŸèƒ½ï¼ï¼ˆCCW: bushiï¼‰
## åŠ è½½æ–¹å¼ï¼š
### TurboWarp / 02Engine / Mistium / Penguin mod: ç›®å‰æ”¯æŒ
ã€æ‰©å±•ã€‘-&gt; è‡ªå®šä¹‰æ‰©å±• -&gt; æ–‡æœ¬ -&gt; ç²˜è´´å†…å®¹
### Gandi IDE : æš‚ä¸æ”¯æŒ
## ä»£ç 
éœ€å¤åˆ¶å†…å®¹å¦‚ä¸‹ï¼š
```js
(function () {
	class Leaderboard {
		constructor(runtime) {
			this.runtime = runtime;
			this.storageKey = 'achieve_and_leaderboard';
			this._port = 'default';
			this._inMemoryStore = {};
 			this._cloudProvider = null;
 			this._cloudAutoSync = false;
			this._overlayElement = null;
			this._overlayMode = null;
			this._overlayContext = null;
			this._stylesInjected = false;
			this._lang = this._detectLang();
			const vers_num = '1.2.0';
			const build_type = 1;
			const build_version = '001';
			const version = vers_num + ['-alpha-', '-beta-', '-release-'][build_type] + build_version;
			this._translations = {
				'zh-cn': {
					extName: 'æˆå°±ä¸æ’è¡Œæ¦œ',
					label_version: 'V' + version,
					docLink: 'æŸ¥çœ‹æ–‡æ¡£',
					leaderboard: 'æ’è¡Œæ¦œ',
					createBoard: 'åˆ›å»ºæ’è¡Œæ¦œ [BOARD]',
					submitScore: 'æäº¤åˆ†æ•° åç§° [NAME] åˆ†æ•° [SCORE] åˆ° [BOARD]',
					getTop: 'è·å–å‰ [N] å ä» [BOARD]',
					getRank: 'æŸ¥è¯¢ åç§° [NAME] åœ¨ [BOARD] çš„åæ¬¡',
					getHighScore: 'æŸ¥è¯¢ åç§° [NAME] åœ¨ [BOARD] çš„æœ€é«˜åˆ†',
					resetBoard: 'é‡ç½®æ’è¡Œæ¦œ [BOARD]',
					getAllData: 'æ•´ä¸ªæ’è¡Œæ¦œæ•°æ®',
					toggleDisplay: '[TOGGLE] æ’è¡Œæ¦œ [BOARD]',
					achievements: 'æˆå°±ç³»ç»Ÿ',
					createAchievement: 'åˆ›å»ºæˆå°± ID [ID] åç§° [NAME] æ ‡ç­¾ [TAG]',
					awardAchievement: 'é¢å‘æˆå°± ID [ID] æ ‡ç­¾ [TAG] ç»™ ç”¨æˆ· [PLAYER] ï¼ˆå¯é€‰åç§° [NAME]ï¼‰ å¹¶ [DISPLAY] ç»™ç”¨æˆ·',
					isAchievementUnlocked: 'æˆå°± ID [ID] åœ¨ æ ‡ç­¾ [TAG] æ˜¯å¦è¢« ç”¨æˆ· [PLAYER] è§£é”',
					toggleAchievementsDisplay: '[TOGGLE] æˆå°± æ ‡ç­¾ [TAG] ç”¨æˆ· [PLAYER]',
					show: 'æ˜¾ç¤º',
					hide: 'éšè—',
					refresh: 'åˆ·æ–°',
					close: 'å…³é—­',
					nameHeader: 'åç§°',
					scoreHeader: 'åˆ†æ•°',
					noData: '(æ— æ•°æ®)',
					noAchievements: '(æ— æˆå°±)',
					moreRecords: '... è¿˜æœ‰ {n} æ¡è®°å½•',
					unlocked: 'å·²è§£é”',
					locked: 'æœªè§£é”',
					leaderboardTitle: 'æ’è¡Œæ¦œï¼š{board}',
					achievementsTitle: 'æˆå°±ï¼š{tag}ï¼ˆç”¨æˆ·ï¼š{player}ï¼‰'
				},
				'en': {
					extName: 'Achievements &amp; Leaderboards',
					label_version: 'V' + version,
					docLink: 'View Docs',
					leaderboard: 'Leaderboard',
					createBoard: 'Create board [BOARD]',
					submitScore: 'Submit score NAME [NAME] SCORE [SCORE] to [BOARD]',
					getTop: 'Get top [N] from [BOARD]',
					getRank: 'Get rank of NAME [NAME] on [BOARD]',
					getHighScore: 'Get high score of NAME [NAME] on [BOARD]',
					resetBoard: 'Reset board [BOARD]',
					getAllData: 'All leaderboard data',
					toggleDisplay: '[TOGGLE] leaderboard [BOARD]',
					achievements: 'Achievements',
					createAchievement: 'Create achievement ID [ID] NAME [NAME] TAG [TAG]',
					awardAchievement: 'Award achievement ID [ID] TAG [TAG] to PLAYER [PLAYER] (opt NAME [NAME]) and [DISPLAY] to player',
					isAchievementUnlocked: 'Is achievement ID [ID] in TAG [TAG] unlocked by PLAYER [PLAYER]',
					toggleAchievementsDisplay: '[TOGGLE] achievements TAG [TAG] PLAYER [PLAYER]',
					show: 'Show',
					hide: 'Hide',
					refresh: 'Refresh',
					close: 'Close',
					nameHeader: 'Name',
					scoreHeader: 'Score',
					noData: '(no data)',
					noAchievements: '(no achievements)',
					moreRecords: '... {n} more records',
					unlocked: 'Unlocked',
					locked: 'Locked',
					leaderboardTitle: 'Leaderboard: {board}',
					achievementsTitle: 'Achievements: {tag} (Player: {player})'
				},
				'fr': {
					extName: 'SuccÃ¨s et Classements',
					label0: 'Classement &amp; SuccÃ¨s',
					label_version: 'V' + version,
					docLink: 'Voir la doc',
					leaderboard: 'Classement',
					createBoard: 'CrÃ©er classement [BOARD]',
					submitScore: 'Soumettre score NOM [NAME] SCORE [SCORE] Ã  [BOARD]',
					getTop: 'Obtenir top [N] de [BOARD]',
					getRank: 'Rang de NOM [NAME] sur [BOARD]',
					getHighScore: 'Meilleur score de NOM [NAME] sur [BOARD]',
					resetBoard: 'RÃ©initialiser [BOARD]',
					getAllData: 'Toutes les donnÃ©es',
					toggleDisplay: '[TOGGLE] classement [BOARD]',
					achievements: 'SuccÃ¨s',
					createAchievement: 'CrÃ©er succÃ¨s ID [ID] NOM [NAME] TAG [TAG]',
					awardAchievement: 'Attribuer succÃ¨s ID [ID] TAG [TAG] Ã  JOUEUR [PLAYER] (opt NOM [NAME]) et [DISPLAY] au joueur',
					isAchievementUnlocked: 'SuccÃ¨s ID [ID] TAG [TAG] dÃ©bloquÃ© par JOUEUR [PLAYER] ?',
					toggleAchievementsDisplay: '[TOGGLE] succÃ¨s TAG [TAG] JOUEUR [PLAYER]',
					show: 'Afficher',
					hide: 'Masquer',
					refresh: 'RafraÃ®chir',
					close: 'Fermer',
					nameHeader: 'Nom',
					scoreHeader: 'Score',
					noData: '(aucune donnÃ©e)',
					noAchievements: '(aucun succÃ¨s)',
					moreRecords: '... {n} autres enregistrements',
					unlocked: 'DÃ©bloquÃ©',
					locked: 'VerrouillÃ©',
					leaderboardTitle: 'Classement : {board}',
					achievementsTitle: 'SuccÃ¨s : {tag} (Joueur : {player})'
				},
				'es': {
					extName: 'Logros y ClasificaciÃ³n',
					label_version: 'V' + version,
					docLink: 'Ver documentaciÃ³n',
					leaderboard: 'ClasificaciÃ³n',
					createBoard: 'Crear clasificaciÃ³n [BOARD]',
					submitScore: 'Enviar puntuaciÃ³n NOMBRE [NAME] PUNT [SCORE] a [BOARD]',
					getTop: 'Obtener top [N] de [BOARD]',
					getRank: 'Rango de NOMBRE [NAME] en [BOARD]',
					getHighScore: 'Mejor puntuaciÃ³n de NOMBRE [NAME] en [BOARD]',
					resetBoard: 'Reiniciar [BOARD]',
					getAllData: 'Todos los datos',
					toggleDisplay: '[TOGGLE] clasificaciÃ³n [BOARD]',
					achievements: 'Logros',
					createAchievement: 'Crear logro ID [ID] NOMBRE [NAME] TAG [TAG]',
					awardAchievement: 'Otorgar logro ID [ID] TAG [TAG] a JUGADOR [PLAYER] (opt NOMBRE [NAME]) y [DISPLAY] al jugador',
					isAchievementUnlocked: 'Â¿Logro ID [ID] TAG [TAG] desbloqueado por JUGADOR [PLAYER]?',
					toggleAchievementsDisplay: '[TOGGLE] logros TAG [TAG] JUGADOR [PLAYER]',
					show: 'Mostrar',
					hide: 'Ocultar',
					refresh: 'Actualizar',
					close: 'Cerrar',
					nameHeader: 'Nombre',
					scoreHeader: 'Puntos',
					noData: '(sin datos)',
					noAchievements: '(sin logros)',
					moreRecords: '... {n} registros mÃ¡s',
					unlocked: 'Desbloqueado',
					locked: 'Bloqueado',
					leaderboardTitle: 'ClasificaciÃ³n: {board}',
					achievementsTitle: 'Logros: {tag} (Usuario: {player})'
				},
				'ru': {
					extName: 'Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ Ğ¸ Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ»Ğ¸Ğ´ĞµÑ€Ğ¾Ğ²',
					label_version: 'V' + version,
					docLink: 'ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ',
					leaderboard: 'Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ»Ğ¸Ğ´ĞµÑ€Ğ¾Ğ²',
					createBoard: 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ [BOARD]',
					submitScore: 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ñ‡ĞºĞ¸ Ğ˜ĞœĞ¯ [NAME] ĞĞ§ĞšĞ˜ [SCORE] Ğ² [BOARD]',
					getTop: 'ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ¿ [N] Ğ¸Ğ· [BOARD]',
					getRank: 'Ğ Ğ°Ğ½Ğ³ Ğ˜ĞœĞ¯ [NAME] Ğ² [BOARD]',
					getHighScore: 'Ğ›ÑƒÑ‡ÑˆĞ¸Ğ¹ ÑÑ‡ĞµÑ‚ Ğ˜ĞœĞ¯ [NAME] Ğ² [BOARD]',
					resetBoard: 'Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ [BOARD]',
					getAllData: 'Ğ’ÑĞµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ',
					toggleDisplay: '[TOGGLE] Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° [BOARD]',
					achievements: 'Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ',
					createAchievement: 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ ID [ID] Ğ˜ĞœĞ¯ [NAME] TAG [TAG]',
					awardAchievement: 'Ğ’Ñ€ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ ID [ID] TAG [TAG] Ğ¸Ğ³Ñ€Ğ¾ĞºÑƒ [PLAYER] (Ğ¸Ğ¼Ñ [NAME]) Ğ¸ [DISPLAY]',
					isAchievementUnlocked: 'Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ ID [ID] Ğ² TAG [TAG] Ñ€Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ¼ [PLAYER] ?',
					toggleAchievementsDisplay: '[TOGGLE] Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ TAG [TAG] Ğ˜Ğ“Ğ ĞĞš [PLAYER]',
					show: 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ',
					hide: 'Ğ¡ĞºÑ€Ñ‹Ñ‚ÑŒ',
					refresh: 'ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ',
					close: 'Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ',
					nameHeader: 'Ğ˜Ğ¼Ñ',
					scoreHeader: 'ĞÑ‡ĞºĞ¸',
					noData: '(Ğ½ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…)',
					noAchievements: '(Ğ½ĞµÑ‚ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¹)',
					moreRecords: '... ĞµÑ‰Ñ‘ {n} Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹',
					unlocked: 'Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾',
					locked: 'Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾',
					leaderboardTitle: 'Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°: {board}',
					achievementsTitle: 'Ğ”Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ: {tag} (Ğ˜Ğ³Ñ€Ğ¾Ğº: {player})'
				},
				'ar': {
					extName: 'Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª ÙˆÙ„ÙˆØ§Ø¦Ø­ Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†',
					label_version: 'V' + version,
					docLink: 'Ø¹Ø±Ø¶ Ø§Ù„ÙˆØ«Ø§Ø¦Ù‚',
					leaderboard: 'Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†',
					createBoard: 'Ø¥Ù†Ø´Ø§Ø¡ Ù‚Ø§Ø¦Ù…Ø© [BOARD]',
					submitScore: 'Ø¥Ø±Ø³Ø§Ù„ Ù†Ù‚Ø§Ø· Ø§Ù„Ø§Ø³Ù… [NAME] Ø§Ù„Ù†Ù‚Ø§Ø· [SCORE] Ø¥Ù„Ù‰ [BOARD]',
					getTop: 'Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¹Ù„Ù‰ [N] Ù…Ù† [BOARD]',
					getRank: 'ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§Ø³Ù… [NAME] ÙÙŠ [BOARD]',
					getHighScore: 'Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø© Ù„Ù„Ø§Ø³Ù… [NAME] ÙÙŠ [BOARD]',
					resetBoard: 'Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† [BOARD]',
					getAllData: 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
					toggleDisplay: '[TOGGLE] Ù‚Ø§Ø¦Ù…Ø© [BOARD]',
					achievements: 'Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª',
					createAchievement: 'Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ù†Ø¬Ø§Ø² ID [ID] Ø§Ù„Ø§Ø³Ù… [NAME] Ø§Ù„ÙˆØ³Ù… [TAG]',
					awardAchievement: 'Ù…Ù†Ø­ Ø¥Ù†Ø¬Ø§Ø² ID [ID] Ø§Ù„ÙˆØ³Ù… [TAG] Ù„Ù„Ø§Ø¹Ø¨ [PLAYER] (Ø§Ù„Ø§Ø³Ù… [NAME]) Ùˆ[DISPLAY]',
					isAchievementUnlocked: 'Ù‡Ù„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² ID [ID] ÙÙŠ Ø§Ù„ÙˆØ³Ù… [TAG] ØªÙ… ÙØªØ­Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© [PLAYER]ØŸ',
					toggleAchievementsDisplay: '[TOGGLE] Ø¥Ù†Ø¬Ø§Ø²Ø§Øª Ø§Ù„ÙˆØ³Ù… [TAG] Ø§Ù„Ù„Ø§Ø¹Ø¨ [PLAYER]',
					show: 'Ø¹Ø±Ø¶',
					hide: 'Ø¥Ø®ÙØ§Ø¡',
					refresh: 'ØªØ­Ø¯ÙŠØ«',
					close: 'Ø¥ØºÙ„Ø§Ù‚',
					nameHeader: 'Ø§Ù„Ø§Ø³Ù…',
					scoreHeader: 'Ø§Ù„Ù†Ù‚Ø§Ø·',
					noData: '(Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª)',
					noAchievements: '(Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ù†Ø¬Ø§Ø²Ø§Øª)',
					moreRecords: '... {n} Ø³Ø¬Ù„Ø§Øª Ø£Ø®Ø±Ù‰',
					unlocked: 'ØªÙ… Ø§Ù„ÙØªØ­',
					locked: 'Ù…Ù‚ÙÙ„',
					leaderboardTitle: 'Ù‚Ø§Ø¦Ù…Ø©: {board}',
					achievementsTitle: 'Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª: {tag} (Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {player})'
				},
				'ja': {
					extName: 'å®Ÿç¸¾ã¨ãƒ©ãƒ³ã‚­ãƒ³ã‚°',
					label_version: 'V' + version,
					docLink: 'ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã‚‹',
					leaderboard: 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°',
					createBoard: 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä½œæˆ [BOARD]',
					submitScore: 'ã‚¹ã‚³ã‚¢ã‚’é€ä¿¡ åå‰ [NAME] ã‚¹ã‚³ã‚¢ [SCORE] ã¸ [BOARD]',
					getTop: '[BOARD] ã®ä¸Šä½ [N] ã‚’å–å¾—',
					getRank: '[BOARD] ã® åå‰ [NAME] ã®é †ä½',
					getHighScore: '[BOARD] ã® åå‰ [NAME] ã®æœ€é«˜ã‚¹ã‚³ã‚¢',
					resetBoard: 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ [BOARD]',
					getAllData: 'ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿',
					toggleDisplay: '[TOGGLE] ãƒ©ãƒ³ã‚­ãƒ³ã‚° [BOARD]',
					achievements: 'å®Ÿç¸¾',
					createAchievement: 'å®Ÿç¸¾ä½œæˆ ID [ID] åå‰ [NAME] ã‚¿ã‚° [TAG]',
					awardAchievement: 'å®Ÿç¸¾ ID [ID] ã‚¿ã‚° [TAG] ã‚’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ [PLAYER] ã«ä»˜ä¸ (åå‰ [NAME]) ã¨[DISPLAY]',
					isAchievementUnlocked: 'å®Ÿç¸¾ ID [ID] ã‚¿ã‚° [TAG] ãŒ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ [PLAYER] ã«ã‚ˆã£ã¦è§£é™¤ã•ã‚Œã¦ã„ã‚‹ã‹',
					toggleAchievementsDisplay: '[TOGGLE] å®Ÿç¸¾ ã‚¿ã‚° [TAG] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ [PLAYER]',
					show: 'è¡¨ç¤º',
					hide: 'éè¡¨ç¤º',
					refresh: 'æ›´æ–°',
					close: 'é–‰ã˜ã‚‹',
					nameHeader: 'åå‰',
					scoreHeader: 'ã‚¹ã‚³ã‚¢',
					noData: '(ãƒ‡ãƒ¼ã‚¿ãªã—)',
					noAchievements: '(å®Ÿç¸¾ãªã—)',
					moreRecords: '... ã‚ã¨ {n} ä»¶',
					unlocked: 'è§£é™¤æ¸ˆã¿',
					locked: 'ãƒ­ãƒƒã‚¯ä¸­',
					leaderboardTitle: 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼š{board}',
					achievementsTitle: 'å®Ÿç¸¾ï¼š{tag}ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼š{player}ï¼‰'
				},
				'ko': {
					extName: 'ì—…ì  ë° ìˆœìœ„í‘œ',
					label_version: 'V' + version,
					docLink: 'ë¬¸ì„œ ë³´ê¸°',
					leaderboard: 'ìˆœìœ„í‘œ',
					createBoard: 'ìˆœìœ„í‘œ ìƒì„± [BOARD]',
					submitScore: 'ì ìˆ˜ ì œì¶œ ì´ë¦„ [NAME] ì ìˆ˜ [SCORE] ì— [BOARD]',
					getTop: '[BOARD] ì—ì„œ ìƒìœ„ [N] ê°€ì ¸ì˜¤ê¸°',
					getRank: '[BOARD] ì—ì„œ ì´ë¦„ [NAME] ë­í¬',
					getHighScore: '[BOARD] ì—ì„œ ì´ë¦„ [NAME] ìµœê³ ì ',
					resetBoard: 'ìˆœìœ„í‘œ ì´ˆê¸°í™” [BOARD]',
					getAllData: 'ëª¨ë“  ë°ì´í„°',
					toggleDisplay: '[TOGGLE] ìˆœìœ„í‘œ [BOARD]',
					achievements: 'ì—…ì ',
					createAchievement: 'ì—…ì  ìƒì„± ID [ID] ì´ë¦„ [NAME] íƒœê·¸ [TAG]',
					awardAchievement: 'ì—…ì  ID [ID] íƒœê·¸ [TAG] ë¥¼ í”Œë ˆì´ì–´ [PLAYER] ì—ê²Œ ìˆ˜ì—¬ (ì´ë¦„ [NAME]) ë° [DISPLAY]',
					isAchievementUnlocked: 'ì—…ì  ID [ID] íƒœê·¸ [TAG] ì´ í”Œë ˆì´ì–´ [PLAYER] ì— ì˜í•´ í•´ì œë˜ì—ˆëŠ”ê°€?',
					toggleAchievementsDisplay: '[TOGGLE] ì—…ì  íƒœê·¸ [TAG] í”Œë ˆì´ì–´ [PLAYER]',
					show: 'í‘œì‹œ',
					hide: 'ìˆ¨ê¸°ê¸°',
					refresh: 'ìƒˆë¡œê³ ì¹¨',
					close: 'ë‹«ê¸°',
					nameHeader: 'ì´ë¦„',
					scoreHeader: 'ì ìˆ˜',
					noData: '(ë°ì´í„° ì—†ìŒ)',
					noAchievements: '(ì—…ì  ì—†ìŒ)',
					moreRecords: '... {n} ê°œì˜ ì¶”ê°€ ê¸°ë¡',
					unlocked: 'í•´ì œë¨',
					locked: 'ì ê¹€',
					leaderboardTitle: 'ìˆœìœ„í‘œ: {board}',
					achievementsTitle: 'ì—…ì : {tag} (ì‚¬ìš©ì: {player})'
				},
				'pt': {
					extName: 'Conquistas e Rankings',
					label_version: 'V' + version,
					docLink: 'Ver documentaÃ§Ã£o',
					leaderboard: 'Ranking',
					createBoard: 'Criar ranking [BOARD]',
					submitScore: 'Enviar pontuaÃ§Ã£o NOME [NAME] PONT [SCORE] para [BOARD]',
					getTop: 'Obter top [N] de [BOARD]',
					getRank: 'PosiÃ§Ã£o de NOME [NAME] em [BOARD]',
					getHighScore: 'Maior pontuaÃ§Ã£o de NOME [NAME] em [BOARD]',
					resetBoard: 'Resetar [BOARD]',
					getAllData: 'Todos os dados',
					toggleDisplay: '[TOGGLE] ranking [BOARD]',
					achievements: 'Conquistas',
					createAchievement: 'Criar conquista ID [ID] NOME [NAME] TAG [TAG]',
					awardAchievement: 'Conceder conquista ID [ID] TAG [TAG] para JOGADOR [PLAYER] (nome [NAME]) e [DISPLAY] ao jogador',
					isAchievementUnlocked: 'Conquista ID [ID] TAG [TAG] desbloqueada por JOGADOR [PLAYER] ?',
					toggleAchievementsDisplay: '[TOGGLE] conquistas TAG [TAG] JOGADOR [PLAYER]',
					show: 'Mostrar',
					hide: 'Esconder',
					refresh: 'Atualizar',
					close: 'Fechar',
					nameHeader: 'Nome',
					scoreHeader: 'Pontos',
					noData: '(sem dados)',
					noAchievements: '(sem conquistas)',
					moreRecords: '... {n} registros a mais',
					unlocked: 'Desbloqueado',
					locked: 'Bloqueado',
					leaderboardTitle: 'Ranking: {board}',
					achievementsTitle: 'Conquistas: {tag} (Jogador: {player})'
				},
				'it': {
					extName: 'Obiettivi e Classifiche',
					label_version: 'V' + version,
					docLink: 'Vedi documentazione',
					leaderboard: 'Classifica',
					createBoard: 'Crea classifica [BOARD]',
					submitScore: 'Invia punteggio NOME [NAME] PUNT [SCORE] a [BOARD]',
					getTop: 'Prendi top [N] da [BOARD]',
					getRank: 'Classifica di NOME [NAME] su [BOARD]',
					getHighScore: 'Miglior punteggio di NOME [NAME] su [BOARD]',
					resetBoard: 'Resetta [BOARD]',
					getAllData: 'Tutti i dati',
					toggleDisplay: '[TOGGLE] classifica [BOARD]',
					achievements: 'Obiettivi',
					createAchievement: 'Crea obiettivo ID [ID] NOME [NAME] TAG [TAG]',
					awardAchievement: 'Assegna obiettivo ID [ID] TAG [TAG] a GIOCATORE [PLAYER] (nome [NAME]) e [DISPLAY] al giocatore',
					isAchievementUnlocked: 'Obiettivo ID [ID] TAG [TAG] sbloccato da GIOCATORE [PLAYER] ?',
					toggleAchievementsDisplay: '[TOGGLE] obiettivi TAG [TAG] GIOCATORE [PLAYER]',
					show: 'Mostra',
					hide: 'Nascondi',
					refresh: 'Aggiorna',
					close: 'Chiudi',
					nameHeader: 'Nome',
					scoreHeader: 'Punteggio',
					noData: '(nessun dato)',
					noAchievements: '(nessun obiettivo)',
					moreRecords: '... {n} record in piÃ¹',
					unlocked: 'Sbloccato',
					locked: 'Bloccato',
					leaderboardTitle: 'Classifica: {board}',
					achievementsTitle: 'Obiettivi: {tag} (Giocatore: {player})'
				}
			};
		}

		_detectLang() {
			try {
				const nav = (typeof navigator !== 'undefined' &amp;&amp; navigator.language) ? navigator.language.toLowerCase() : 'en';
				if (nav.startsWith('zh')) return 'zh-cn';
				if (nav.startsWith('fr')) return 'fr';
				if (nav.startsWith('es')) return 'es';
				if (nav.startsWith('ru')) return 'ru';
				if (nav.startsWith('ar')) return 'ar';
				if (nav.startsWith('ja')) return 'ja';
				if (nav.startsWith('ko')) return 'ko';
				if (nav.startsWith('pt')) return 'pt';
				if (nav.startsWith('it')) return 'it';
				return 'en';
			} catch (e) {
				return 'en';
			}
		}

		_t(key, vars) {
			const dict = this._translations &amp;&amp; this._translations[this._lang] ? this._translations[this._lang] : this._translations['en'];
			let s = (dict &amp;&amp; dict[key]) ? dict[key] : (this._translations['en'][key] || key);
			if (vars &amp;&amp; typeof vars === 'object') {
				Object.keys(vars).forEach(k =&gt; {
					s = s.replace(new RegExp(`\\{${k}\\}`, 'g'), String(vars[k]));
				});
			}
			return s;
		}

		getInfo() {
			const B = (window.Scratch &amp;&amp; window.Scratch.BlockType) ? window.Scratch.BlockType : { COMMAND: 'command', REPORTER: 'reporter' };
			const A = (window.Scratch &amp;&amp; window.Scratch.ArgumentType) ? window.Scratch.ArgumentType : { STRING: 'string', NUMBER: 'number' };
			const BUTTON = (B &amp;&amp; B.BUTTON) ? B.BUTTON : B.COMMAND;
            return {
				id: 'leaderboard_and_achievements',
				name: this._t('extName'),
				color1: '#3494fc',
				color2: '#3494fc',
				color3: '#3494fc',
				blocks: [
                    { opcode: 'label', blockType: B.LABEL, text: `â€”â€”â€” ${this._t('extName')} â€”â€”â€”` },
                    { opcode: 'label_version', blockType: B.LABEL, text: this._t('label_version')},
                    { opcode: 'docLink', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('docLink') },
					{ opcode: 'leaderboard_text', blockType: B.LABEL, text: ` ${this._t('leaderboard')}`},
					{ opcode: 'createBoard', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('createBoard'),
						arguments: { BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'submitScore', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('submitScore'),
						arguments: { NAME: { type: A.STRING, defaultValue: 'ç©å®¶' }, SCORE: { type: A.NUMBER, defaultValue: 0 }, BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'getTop', blockType: B.REPORTER, text: 'ğŸ† ' + this._t('getTop'),
						arguments: { N: { type: A.NUMBER, defaultValue: 10 }, BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'getRank', blockType: B.REPORTER, text: 'ğŸ† ' + this._t('getRank'),
						arguments: { NAME: { type: A.STRING, defaultValue: 'ç©å®¶' }, BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'getHighScore', blockType: B.REPORTER, text: 'ğŸ† ' + this._t('getHighScore'),
						arguments: { NAME: { type: A.STRING, defaultValue: 'ç©å®¶' }, BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'resetBoard', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('resetBoard'),
						arguments: { BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'getAllData', blockType: B.REPORTER, text: 'ğŸ† ' + this._t('getAllData') },
					{ opcode: 'toggleDisplay', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('toggleDisplay'),
						arguments: { TOGGLE: {type: A.STRING, menu: 'toggle'}, BOARD: { type: A.STRING, defaultValue: 'é»˜è®¤æ’è¡Œæ¦œ' } } },
					{ opcode: 'cloud_text', blockType: B.LABEL, text: ' äº‘å­˜å‚¨' },
					{ opcode: 'pushAllToCloud', blockType: B.COMMAND, text: 'æ¨é€å…¨éƒ¨åˆ°äº‘ç«¯' },
					{ opcode: 'pullAllFromCloud', blockType: B.COMMAND, text: 'ä»äº‘ç«¯æ‹‰å–å…¨éƒ¨' },
					{ opcode: 'setPort', blockType: B.COMMAND, text: 'è®¾ç½®ç«¯å£ [PORT]', arguments: { PORT: { type: A.STRING, defaultValue: 'default' } } },
					{ opcode: 'getPort', blockType: B.REPORTER, text: 'å½“å‰ç«¯å£' },
					{ opcode: 'setCloudAutoSync', blockType: B.COMMAND, text: 'è‡ªåŠ¨äº‘åŒæ­¥ [TOGGLE]',
						arguments: { TOGGLE: { type: A.STRING, menu: 'toggle' } } },
					{ opcode: 'achievement_text', blockType: B.LABEL, text: ` ${this._t('achievements')}`},
					{ opcode: 'createAchievement', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('createAchievement'),
						arguments: { ID: { type: A.STRING, defaultValue: 'achv1' }, NAME: { type: A.STRING, defaultValue: 'æˆå°±åç§°' }, TAG: { type: A.STRING, defaultValue: 'é»˜è®¤æ ‡ç­¾' } } },
					{ opcode: 'awardAchievement', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('awardAchievement'),
						arguments: { ID: { type: A.STRING, defaultValue: 'achv1' }, TAG: { type: A.STRING, defaultValue: 'é»˜è®¤æ ‡ç­¾' }, PLAYER: { type: A.STRING, defaultValue: 'ç©å®¶' }, NAME: { type: A.STRING, defaultValue: '' }, DISPLAY: { type: A.STRING, menu: 'display' } } },
					{ opcode: 'isAchievementUnlocked', blockType: B.REPORTER, text: 'ğŸ† ' + this._t('isAchievementUnlocked'),
						arguments: { ID: { type: A.STRING, defaultValue: 'achv1' }, TAG: { type: A.STRING, defaultValue: 'é»˜è®¤æ ‡ç­¾' }, PLAYER: { type: A.STRING, defaultValue: 'ç©å®¶' } } },
					{ opcode: 'toggleAchievementsDisplay', blockType: B.COMMAND, text: 'ğŸ† ' + this._t('toggleAchievementsDisplay'),
						arguments: { TOGGLE: {type: A.STRING, menu: 'toggle'}, TAG: { type: A.STRING, defaultValue: 'é»˜è®¤æ ‡ç­¾' }, PLAYER: { type: A.STRING, defaultValue: 'ç©å®¶' } } }
				],
				menus: {
                    toggle: [
                        { text: this._t('show'), value: 'open' },
                        { text: this._t('hide'), value: 'close' }
                    ],
 					display: [
 						{ text: this._t('show'), value: 'show' },
 						{ text: this._t('hide'), value: 'hide' }
 					]
                 }
 			};
 		}

		_storageKeyForPort() {
			return String(this.storageKey || 'achieve_and_leaderboard') + ':' + String(this._port || 'default');
		}

		_loadAll() {
			try {
				if (typeof localStorage !== 'undefined') {
					const key = this._storageKeyForPort();
					const raw = localStorage.getItem(key);
					if (raw) {
						try { return JSON.parse(raw); } catch (e) {}
					}
					const legacyRaw = localStorage.getItem(this.storageKey);
					if (legacyRaw) {
						try {
							const parsed = JSON.parse(legacyRaw);
							try { localStorage.setItem(key, JSON.stringify(parsed)); } catch (e) {}
							return parsed;
						} catch (e) {}
					}
				}
			} catch (e) {}
			return this._inMemoryStore[this._port] ? this._inMemoryStore[this._port] : {};
 		}
 
 		_saveAll(data) {
			try {
				const key = this._storageKeyForPort();
				if (typeof localStorage !== 'undefined') {
					localStorage.setItem(key, JSON.stringify(data));
				} else {
					this._inMemoryStore[this._port] = data;
				}
			} catch (e) {
				this._inMemoryStore[this._port] = data;
			}
			if (this._cloudProvider &amp;&amp; this._cloudAutoSync &amp;&amp; typeof this._cloudProvider.upload === 'function') {
				try {
					const payload = JSON.stringify(data);
					Promise.resolve(this._cloudProvider.upload(this._storageKeyForPort(), payload)).catch(() =&gt; {});
				} catch (e) {}
			}
 		}
 
 		registerCloudProvider(provider) {
 			if (!provider) return false;
 			this._cloudProvider = provider;
 			return true;
 		}
 
 		async _pushAllToCloud() {
			if (!this._cloudProvider || typeof this._cloudProvider.upload !== 'function') return false;
			const all = this._loadAll();
			try {
				await this._cloudProvider.upload(this._storageKeyForPort(), JSON.stringify(all));
				return true;
			} catch (e) {
				return false;
			}
 		}
 
 		async _pullAllFromCloud() {
			if (!this._cloudProvider || typeof this._cloudProvider.download !== 'function') return false;
			try {
				const raw = await this._cloudProvider.download(this._storageKeyForPort());
				if (!raw) return false;
				let parsed = {};
				try { parsed = JSON.parse(raw); } catch (e) { return false; }
				this._saveAll(parsed);
				return true;
			} catch (e) {
				return false;
			}
 		}
 
 		pushAllToCloud(args) {
 			if (typeof this._pushAllToCloud === 'function') this._pushAllToCloud().catch(() =&gt; {});
 		}
 
 		pullAllFromCloud(args) {
 			if (typeof this._pullAllFromCloud === 'function') this._pullAllFromCloud().catch(() =&gt; {});
 		}
 
 		setCloudAutoSync(args) {
 			const toggle = String((args &amp;&amp; args.TOGGLE) || '').toLowerCase();
 			if (toggle === 'open' || toggle === 'show' || toggle === 'true' || toggle === '1') this.setCloudAutoSyncEnabled(true);
 			else if (toggle === 'close' || toggle === 'hide' || toggle === 'false' || toggle === '0') this.setCloudAutoSyncEnabled(false);
 		}
 
 		setCloudAutoSyncEnabled(enabled) {
 			this._cloudAutoSync = !!enabled;
 		}
 
 		_ensureBoard(data, board) {
 			if (!data[board]) data[board] = {};
 			return data[board];
 		}

        docLink() {
            const url = 'https://chess-brain.github.io/doc/achievements_and_leaderboards.html';
            if (typeof window === 'undefined') return;
            try {
                this._openUrl(url);
            } catch (e) {}
        }

		createBoard(args) {
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ');
			const all = this._loadAll();
			this._ensureBoard(all, board);
			this._saveAll(all);
		}

		submitScore(args) {
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ');
			const name = String(args.NAME || 'ç©å®¶');
			const score = Number(args.SCORE) || 0;
			const all = this._loadAll();
			const b = this._ensureBoard(all, board);
			const prev = b[name];
			const now = Date.now();
			if (!prev || score &gt; prev.score || (score === prev.score &amp;&amp; now &lt; prev.ts)) {
				b[name] = { score: score, ts: now };
			}
			this._saveAll(all);
		}

		getTop(args) {
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ');
			const n = Math.max(0, Math.floor(Number(args.N) || 0));
			const all = this._loadAll();
			const b = all[board] || {};
			const arr = Object.keys(b).map(name =&gt; ({ name, score: Number(b[name].score), ts: Number(b[name].ts) }));
			arr.sort((a, c) =&gt; {
				if (c.score !== a.score) return c.score - a.score;
				return a.ts - c.ts;
			});
			const top = arr.slice(0, n).map((item, idx) =&gt; ({ rank: idx + 1, name: item.name, score: item.score }));
			try {
				return JSON.stringify(top);
			} catch (e) {
				return '[]';
			}
		}

		getRank(args) {
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ');
			const name = String(args.NAME || 'ç©å®¶');
			const all = this._loadAll();
			const b = all[board] || {};
			const arr = Object.keys(b).map(nm =&gt; ({ name: nm, score: Number(b[nm].score), ts: Number(b[nm].ts) }));
			arr.sort((a, c) =&gt; {
				if (c.score !== a.score) return c.score - a.score;
				return a.ts - c.ts;
			});
			for (let i = 0; i &lt; arr.length; i++) {
				if (arr[i].name === name) return i + 1;
			}
			return 0;
		}

		getHighScore(args) {
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ');
			const name = String(args.NAME || 'ç©å®¶');
			const all = this._loadAll();
			const b = all[board] || {};
			const entry = b[name];
			return entry ? Number(entry.score) : 0;
		}

		resetBoard(args) {
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ');
			const all = this._loadAll();
			if (all[board]) delete all[board];
			this._saveAll(all);
		}

		getAllData() {
			const all = this._loadAll();
			all.__achievements_meta = all.__achievements_meta || {};
			all.__achievements_unlocked = all.__achievements_unlocked || {};
			try {
				return JSON.stringify(all);
			} catch (e) {
				return '{}';
			}
		}

		toggleDisplay(args) {
			const toggle = String((args.TOGGLE || '')).toLowerCase();
			const board = String(args.BOARD || 'é»˜è®¤æ’è¡Œæ¦œ').trim();
			if (toggle === 'open') {
				this._showOverlay(board);
				return;
			}
			if (toggle === 'close') {
				if (this._overlayElement &amp;&amp; this._overlayMode === 'leaderboard') this._hideOverlay();
				return;
			}
			if (this._overlayElement &amp;&amp; this._overlayMode === 'leaderboard' &amp;&amp; this._overlayContext &amp;&amp; this._overlayContext.board === board) {
				this._hideOverlay();
			} else {
				this._showOverlay(board);
			}
		}

		_ensureAchievementMeta(all) {
			if (!all.__achievements_meta) all.__achievements_meta = {};
			return all.__achievements_meta;
		}
		_ensureAchievementUnlocked(all) {
			if (!all.__achievements_unlocked) all.__achievements_unlocked = {};
			return all.__achievements_unlocked;
		}

		createAchievement(args) {
			const id = String(args.ID || '');
			const name = String(args.NAME || '');
			const tag = String(args.TAG || 'é»˜è®¤æ ‡ç­¾');
			if (!id) return;
			const all = this._loadAll();
			const meta = this._ensureAchievementMeta(all);
			if (!meta[tag]) meta[tag] = {};
			meta[tag][id] = { name: name || id };
			this._saveAll(all);
		}

		awardAchievement(args) {
			const id = String(args.ID || '');
			const tag = String(args.TAG || 'é»˜è®¤æ ‡ç­¾');
			const player = String(args.PLAYER || 'ç©å®¶');
			const name = String(args.NAME || '');
			if (!id) return;
			const all = this._loadAll();
			const meta = this._ensureAchievementMeta(all);
			if (!meta[tag]) meta[tag] = {};
			if (name) meta[tag][id] = { name: name };
			const unlocked = this._ensureAchievementUnlocked(all);
			if (!unlocked[player]) unlocked[player] = {};
			if (!unlocked[player][tag]) unlocked[player][tag] = {};
			unlocked[player][tag][id] = { ts: Date.now() };
			this._saveAll(all);
			const display = String((args &amp;&amp; args.DISPLAY) || '').toLowerCase();
			if (display === 'show') {
				const displayName = (meta[tag] &amp;&amp; meta[tag][id] &amp;&amp; meta[tag][id].name) ? meta[tag][id].name : (name || id);
				this._showDynamicHint('ğŸ† ' + this._t('unlocked') + ': ' + displayName);
			}
		}

		isAchievementUnlocked(args) {
			const id = String(args.ID || '');
			const tag = String(args.TAG || 'é»˜è®¤æ ‡ç­¾');
			const player = String(args.PLAYER || 'ç©å®¶');
			if (!id) return false;
			const all = this._loadAll();
			const unlocked = all.__achievements_unlocked || {};
			return !!(unlocked[player] &amp;&amp; unlocked[player][tag] &amp;&amp; unlocked[player][tag][id]);
		}

		_ensureStyles() {
			if (this._stylesInjected || typeof document === 'undefined') {
				if (typeof document !== 'undefined' &amp;&amp; document.getElementById &amp;&amp; document.getElementById('turbo-leaderboard-styles')) {
					this._stylesInjected = true;
				}
				return;
			}
			const css = `
				#turbo-leaderboard-overlay {
					position: fixed;
					right: 12px;
					top: 12px;
					max-height: 70vh;
					overflow: auto;
					z-index: 999999;
					background: rgba(255,255,255,0.5);
					color: #111;
					padding: 12px;
					border-radius: 12px;
					font-family: 'Helvetica Neue', Arial, sans-serif;
					font-size: 13px;
					min-width: 300px;
					box-shadow: 0 8px 24px rgba(0,0,0,0.12);
					backdrop-filter: blur(4px);
					border: 1px solid rgba(0,0,0,0.06);
				}
				#turbo-leaderboard-overlay .lb-title {
					display:flex;
					align-items:center;
					justify-content:space-between;
					gap:8px;
					margin-bottom:8px;
				}
				#turbo-leaderboard-overlay .lb-title .title-text {
					font-weight:700;
					font-size:14px;
					color: #222;
				}
				#turbo-leaderboard-overlay .lb-controls button {
					background: rgba(0,0,0,0.04);
					border: 1px solid rgba(0,0,0,0.06);
					color: #111;
					padding:4px 8px;
					border-radius:6px;
					cursor:pointer;
					font-size:12px;
				}
				#turbo-leaderboard-overlay table.lb-table {
					width:100%;
					border-collapse:collapse;
					table-layout:fixed;
				}
				#turbo-leaderboard-overlay table.lb-table th,
				#turbo-leaderboard-overlay table.lb-table td {
					padding:6px 8px;
					overflow:hidden;
					text-overflow:ellipsis;
					white-space:nowrap;
					color: #111;
				}
				#turbo-leaderboard-overlay table.lb-table th.rank,
				#turbo-leaderboard-overlay table.lb-table td.rank {
					width:40px;
					text-align:left;
				}
				#turbo-leaderboard-overlay table.lb-table td.name {
					text-align:left;
				}
				#turbo-leaderboard-overlay table.lb-table td.score {
					width:70px;
					text-align:right;
					font-weight:600;
				}
				#turbo-leaderboard-overlay .lb-row:nth-child(odd){
					background: rgba(0,0,0,0.02);
				}
				#turbo-leaderboard-overlay .badge {
					display:inline-block;
					min-width:24px;
					padding:2px 6px;
					border-radius:12px;
					font-weight:700;
					font-size:12px;
					text-align:center;
					margin-right:6px;
				}
				#turbo-leaderboard-overlay .badge.gold{ background: linear-gradient(90deg,#ffd700,#ffdd66); color:#1b1b1b; }
				#turbo-leaderboard-overlay .badge.silver{ background: linear-gradient(90deg,#e6e6e6,#cfcfcf); color:#1b1b1b; }
				#turbo-leaderboard-overlay .badge.bronze{ background: linear-gradient(90deg,#cd7f32,#d99b6a); color:#fff; }
				#turbo-leaderboard-overlay .name-wrap { max-width: 140px; display:inline-block; vertical-align:middle; }
				#turbo-leaderboard-overlay .achv-unlocked { color: #2e7d32; font-weight:700; }
				#turbo-leaderboard-overlay .achv-locked { color: #7b7b7b; }
			`;
			const style = document.createElement('style');
			style.id = 'turbo-leaderboard-styles';
			style.textContent = css;
			document.head.appendChild(style);
			this._stylesInjected = true;
		}

		_createOverlay() {
			this._ensureStyles();
			const el = document.createElement('div');
			el.id = 'turbo-leaderboard-overlay';
			el.style.display = 'none';

			const titleBar = document.createElement('div');
			titleBar.className = 'lb-title';
			const titleText = document.createElement('div');
			titleText.className = 'title-text';
			titleText.textContent = '';
			titleBar.appendChild(titleText);

			const controls = document.createElement('div');
			controls.className = 'lb-controls';
			const refreshBtn = document.createElement('button');
			refreshBtn.textContent = 'ğŸ† ' + this._t('refresh');
			refreshBtn.onclick = () =&gt; {
				if (this._overlayMode === 'leaderboard' &amp;&amp; this._overlayContext) this._showOverlay(this._overlayContext.board);
				else if (this._overlayMode === 'achievements' &amp;&amp; this._overlayContext) this._showAchievements(this._overlayContext.tag, this._overlayContext.player);
			};
			const closeBtn = document.createElement('button');
			closeBtn.textContent = 'ğŸ† ' + this._t('close');
			closeBtn.onclick = () =&gt; this._hideOverlay();
			controls.appendChild(refreshBtn);
			controls.appendChild(closeBtn);
			titleBar.appendChild(controls);
			el.appendChild(titleBar);

			const table = document.createElement('table');
			table.className = 'lb-table';
			const thead = document.createElement('thead');
			const htr = document.createElement('tr');
			const thRank = document.createElement('th'); thRank.className = 'rank'; thRank.textContent = '#';
			const thName = document.createElement('th'); thName.textContent = 'ğŸ† ' + this._t('nameHeader');
			const thRight = document.createElement('th'); thRight.className = 'score'; thRight.textContent = '';
			htr.appendChild(thRank); htr.appendChild(thName); htr.appendChild(thRight);
			thead.appendChild(htr);
			table.appendChild(thead);
			const tbody = document.createElement('tbody');
			tbody.className = 'lb-list';
			table.appendChild(tbody);
			el.appendChild(table);
			el._titleText = titleText;
			el._theadRight = thRight;
			el._tbody = tbody;
			return el;
		}

		_showOverlay(board) {
			const all = this._loadAll();
			const b = all[board] || {};
			const arr = Object.keys(b).map(name =&gt; ({ name, score: Number(b[name].score), ts: Number(b[name].ts) }));
			arr.sort((a, c) =&gt; {
				if (c.score !== a.score) return c.score - a.score;
				return a.ts - c.ts;
			});
			if (!this._overlayElement) {
				this._overlayElement = this._createOverlay();
				document.body.appendChild(this._overlayElement);
			}
			this._overlayMode = 'leaderboard';
			this._overlayContext = { board };
			this._overlayElement._titleText.textContent = 'ğŸ† ' + this._t('leaderboardTitle', { board });
			this._overlayElement._theadRight.textContent = 'ğŸ† ' + this._t('scoreHeader');
			const tbody = this._overlayElement._tbody;
			tbody.innerHTML = '';
			if (arr.length === 0) {
				const tr = document.createElement('tr');
				const td = document.createElement('td');
				td.colSpan = 3;
				td.style.opacity = '0.85';
				td.textContent = 'ğŸ† ' + this._t('noData');
				tr.appendChild(td);
				tbody.appendChild(tr);
			} else {
				const max = Math.min(50, arr.length);
				for (let i = 0; i &lt; max; i++) {
					const it = arr[i];
					const tr = document.createElement('tr');
					tr.className = 'lb-row';
					const tdRank = document.createElement('td'); tdRank.className = 'rank';
					const badge = document.createElement('span'); badge.className = 'badge';
					if (i === 0) badge.classList.add('gold'); else if (i === 1) badge.classList.add('silver'); else if (i === 2) badge.classList.add('bronze');
					badge.textContent = (i + 1);
					tdRank.appendChild(badge);
					tr.appendChild(tdRank);
					const tdName = document.createElement('td'); tdName.className = 'name';
					const nameWrap = document.createElement('span'); nameWrap.className = 'name-wrap'; nameWrap.title = it.name; nameWrap.textContent = it.name;
					tdName.appendChild(nameWrap);
					tr.appendChild(tdName);
					const tdScore = document.createElement('td'); tdScore.className = 'score'; tdScore.textContent = String(it.score);
					tr.appendChild(tdScore);
					tbody.appendChild(tr);
				}
				if (arr.length &gt; max) {
					const tr = document.createElement('tr');
					const td = document.createElement('td'); td.colSpan = 3; td.style.opacity = '0.8';
					td.textContent = 'ğŸ† ' + this._t('moreRecords', { n: arr.length - max });
					tr.appendChild(td);
					tbody.appendChild(tr);
				}
			}
			this._overlayElement.style.display = 'block';
		}
		
		_showAchievements(tag, player) {
			const all = this._loadAll();
			const meta = (all.__achievements_meta &amp;&amp; all.__achievements_meta[tag]) ? all.__achievements_meta[tag] : {};
			const unlockedForPlayer = (all.__achievements_unlocked &amp;&amp; all.__achievements_unlocked[player] &amp;&amp; all.__achievements_unlocked[player][tag]) ? all.__achievements_unlocked[player][tag] : {};
			if (!this._overlayElement) {
				this._overlayElement = this._createOverlay();
				document.body.appendChild(this._overlayElement);
			}
			this._overlayMode = 'achievements';
			this._overlayContext = { tag, player };
			this._overlayElement._titleText.textContent = 'ğŸ† ' + this._t('achievementsTitle', { tag, player });
			this._overlayElement._theadRight.textContent = '';
			const tbody = this._overlayElement._tbody;
			tbody.innerHTML = '';
			const ids = Object.keys(meta);
			if (ids.length === 0) {
				const tr = document.createElement('tr');
				const td = document.createElement('td'); td.colSpan = 3; td.style.opacity = '0.85'; td.textContent = 'ğŸ† ' + this._t('noAchievements');
				tr.appendChild(td); tbody.appendChild(tr);
			} else {
				for (let i = 0; i &lt; ids.length; i++) {
					const id = ids[i];
					const m = meta[id];
					const tr = document.createElement('tr'); tr.className = 'lb-row';
					const tdRank = document.createElement('td'); tdRank.className = 'rank'; tdRank.textContent = (i + 1) + '.';
					tr.appendChild(tdRank);
					const tdName = document.createElement('td'); tdName.className = 'name';
					const nameWrap = document.createElement('span'); nameWrap.className = 'name-wrap'; nameWrap.title = `${m.name} (${id})`; nameWrap.textContent = m.name;
					tdName.appendChild(nameWrap); tr.appendChild(tdName);
					const tdState = document.createElement('td'); tdState.className = 'score';
					if (unlockedForPlayer &amp;&amp; unlockedForPlayer[id]) {
						tdState.innerHTML = `&lt;span class='achv-unlocked'&gt;${'ğŸ† ' + this._t('unlocked')}&lt;/span&gt;`;
					} else {
						tdState.innerHTML = `&lt;span class='achv-locked'&gt;${'ğŸ† ' + this._t('locked')}&lt;/span&gt;`;
					}
					tr.appendChild(tdState);
					tbody.appendChild(tr);
				}
			}
			this._overlayElement.style.display = 'block';
		}

		_hideOverlay() {
			if (this._overlayElement) {
				this._overlayElement.style.display = 'none';
				this._overlayMode = null;
				this._overlayContext = null;
			}
		}
		_hideDocOverlay() {
			try {
				const el = (typeof document !== 'undefined') ? document.getElementById('turbo-doc-overlay') : null;
				if (el &amp;&amp; el.parentNode) el.parentNode.removeChild(el);
			} catch (e) {}
		}
		_openUrl(url) {
			if (typeof window === 'undefined') return;
			try {
				let opened = null;
				try { opened = window.open(url, '_blank', 'noopener'); } catch (e) { opened = null; }
				if (opened) { try { opened.opener = null; opened.focus &amp;&amp; opened.focus(); } catch (e) {} return; }
				try {
					if (window.top &amp;&amp; window.top !== window) {
						let to = null;
						try { to = window.top.open(url, '_blank', 'noopener'); } catch (e) { to = null; }
						if (to) { try { to.opener = null; to.focus &amp;&amp; to.focus(); } catch (e) {} return; }
					}
				} catch (e) {}
				try {
					if (typeof document !== 'undefined') {
						const a = document.createElement('a');
						a.href = url;
						a.target = '_blank';
						a.rel = 'noopener noreferrer';
						a.style.display = 'none';
						document.body.appendChild(a);
						try {
							const evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
							a.dispatchEvent(evt);
						} catch (e) {
							try { a.click(); } catch (e2) {}
						}
						document.body.removeChild(a);
						return;
					}
				} catch (e) {}
				try { window.location.assign(url); } catch (e) {}
			} catch (e) {}
		}
		_showDynamicHint(msg) {
			if (typeof document === 'undefined') return;
			try {
				if (!document.getElementById('turbo-achv-hint-styles')) {
					const s = document.createElement('style');
					s.id = 'turbo-achv-hint-styles';
					s.textContent = '.turbo-achv-hint{position:fixed;left:50%;transform:translateX(-50%) translateY(-8px);top:12px;background:rgba(0,0,0,0.78);color:#fff;padding:8px 12px;border-radius:10px;font-family:'Helvetica Neue',Arial,sans-serif;font-size:13px;z-index:1000000;opacity:0;transition:opacity 0.28s ease,transform 0.28s ease;pointer-events:none;box-shadow:0 6px 18px rgba(0,0,0,0.2)}.turbo-achv-hint.show{opacity:1;transform:translateX(-50%) translateY(0)}';
					document.head.appendChild(s);
				}
				let el = document.getElementById('turbo-achv-hint');
				if (!el) {
					el = document.createElement('div');
					el.id = 'turbo-achv-hint';
					el.className = 'turbo-achv-hint';
					document.body.appendChild(el);
				}
				el.textContent = String(msg || '');
				void el.offsetWidth;
				el.classList.add('show');
				if (el._timeout) clearTimeout(el._timeout);
				el._timeout = setTimeout(function () {
					el.classList.remove('show');
				}, 3000);
			} catch (e) {}
		}
		toggleAchievementsDisplay(args) {
			const toggle = String((args.TOGGLE || '')).toLowerCase();
			const tag = String(args.TAG || 'é»˜è®¤æ ‡ç­¾').trim();
			const player = String(args.PLAYER || 'ç©å®¶').trim();
			if (toggle === 'open') {
				this._showAchievements(tag, player);
				return;
			}
			if (toggle === 'close') {
				if (this._overlayElement &amp;&amp; this._overlayMode === 'achievements') this._hideOverlay();
				return;
			}
			if (this._overlayElement &amp;&amp; this._overlayMode === 'achievements' &amp;&amp; this._overlayContext &amp;&amp; this._overlayContext.tag === tag &amp;&amp; this._overlayContext.player === player) {
				this._hideOverlay();
			} else {
				this._showAchievements(tag, player);
			}
		}
	}

	if (window &amp;&amp; window.Scratch &amp;&amp; window.Scratch.extensions &amp;&amp; window.Scratch.extensions.register) {
		window.Scratch.extensions.register(new Leaderboard());
	} else if (typeof window !== 'undefined') {
		window.LeaderboardExtension = new Leaderboard();
	} else if (typeof module !== 'undefined' &amp;&amp; module.exports) {
		module.exports = Leaderboard;
	}
})();


```ã€‚</description><guid isPermaLink="true">https://chess-brain.github.io/code/post/xiang-qi-nao-de-cheng-jiu-yu-pai-xing-bang.html</guid><pubDate>Wed, 24 Dec 2025 14:45:49 +0000</pubDate></item></channel></rss>